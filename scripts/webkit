#!/bin/bash -e

MESON_BUILD_TYPE=debugoptimized
CMAKE_BUILD_TYPE=RelWithDebInfo
BUILD_DEPS=false

readonly BASE_DIR=$(dirname $(readlink -en $0))/webkit-2.38
readonly INSTALL_PREFIX=$BASE_DIR/dist

readonly LIBWPE=libwpe-1.14.1
readonly WPEWEBKIT=wpewebkit-2.38.6

while [ $# -gt 0 ]; do
    case "$1" in
    --debug)
        MESON_BUILD_TYPE=debug
        CMAKE_BUILD_TYPE=Debug
        ;;

    --release)
        MESON_BUILD_TYPE=release
        CMAKE_BUILD_TYPE=Release
        ;;

    --build)
        BUILD_DEPS=true
        ;;

    *)
        echo "Unkown parameter: $1"
        ;;
    esac
    shift
done

typeset -r MESON_BUILD_TYPE
typeset -r CMAKE_BUILD_TYPE
typeset -r BUILD_DEPS

readonly PKG_PATH=$INSTALL_PREFIX/lib/x86_64-linux-gnu/pkgconfig:$INSTALL_PREFIX/lib/pkgconfig
if [ -n "$PKG_CONFIG_PATH" ]; then
    export PKG_CONFIG_PATH=$PKG_PATH:$PKG_CONFIG_PATH
else
    export PKG_CONFIG_PATH=$PKG_PATH
fi

function install_build_deps
{
    sudo apt-get install -qq \
        pkg-config gperf libegl1-mesa-dev libxkbcommon-dev libatk-bridge2.0-dev libatk1.0-dev libcairo2-dev \
        libepoxy-dev libgbm-dev libgcrypt20-dev libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev libharfbuzz-dev \
        libicu-dev libjpeg-dev liblcms2-dev libopenjp2-7-dev libsoup2.4-dev libsqlite3-dev libsystemd-dev \
        libtasn1-6-dev libwayland-dev libwebp-dev libwoff-dev libxslt1-dev wayland-protocols libglib2.0-dev \
        libgtk-3-dev libfontconfig1-dev libfreetype6-dev libhyphen-dev libmanette-0.2-dev libnotify-dev libxml2-dev \
        libgudev-1.0-dev bison flex libpng-dev libxt-dev libenchant-2-dev libsecret-1-dev libgl-dev \
        libgles-dev libjavascriptcoregtk-4.1-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-gl \
        libgl1-mesa-dri patchelf unifdef ruby-dev libgstreamer-plugins-bad1.0-dev
}

function patch_webkit_wait_for_wpewebprocess
{
    patch -d $WPEWEBKIT -f -l -p1 <<"EOF"
From f6c5fa2ca7ebbc82669e120101ac066b528d9406 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lo=C3=AFc=20Le=20Page?= <llepage@igalia.com>
Date: Mon, 17 Apr 2023 17:45:25 +0200
Subject: [PATCH] Wait for WPEWebProcess without developer mode

---
 Source/WebKit/WebProcess/wpe/WebProcessMainWPE.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Source/WebKit/WebProcess/wpe/WebProcessMainWPE.cpp b/Source/WebKit/WebProcess/wpe/WebProcessMainWPE.cpp
index ff5eeeb0..ac4ee6de 100644
--- a/Source/WebKit/WebProcess/wpe/WebProcessMainWPE.cpp
+++ b/Source/WebKit/WebProcess/wpe/WebProcessMainWPE.cpp
@@ -50,10 +50,10 @@ public:
         PAL::GCrypt::initialize();
 #endif

-#if ENABLE(DEVELOPER_MODE)
+// #if ENABLE(DEVELOPER_MODE)
         if (g_getenv("WEBKIT2_PAUSE_WEB_PROCESS_ON_LAUNCH"))
             WTF::sleep(30_s);
-#endif
+// #endif

         // Required for GStreamer initialization.
         // FIXME: This should be probably called in other processes as well.
--
2.34.1
EOF
}

function patch_webkit_enable_websecurity
{
    patch -d $WPEWEBKIT -f -l -p1 <<"EOF"
From 55a8070fbbfdac663b0c5b64582fb9c31d9279e0 Mon Sep 17 00:00:00 2001
From: Przemyslaw Gorszkowski <pgorszkowski@igalia.com>
Date: Wed, 16 Nov 2022 12:29:08 +0100
Subject: [PATCH] [GTK][WPE] Add provision to enable / disable websecurity
 https://bugs.webkit.org/show_bug.cgi?id=246606

---
 .../UIProcess/API/glib/WebKitSettings.cpp     | 65 +++++++++++++++++++
 .../WebKit/UIProcess/API/wpe/WebKitSettings.h |  6 ++
 .../Tests/WebKitGLib/TestWebKitSettings.cpp   |  5 ++
 3 files changed, 76 insertions(+)

diff --git a/Source/WebKit/UIProcess/API/glib/WebKitSettings.cpp b/Source/WebKit/UIProcess/API/glib/WebKitSettings.cpp
index c79a3fc0..897600ba 100644
--- a/Source/WebKit/UIProcess/API/glib/WebKitSettings.cpp
+++ b/Source/WebKit/UIProcess/API/glib/WebKitSettings.cpp
@@ -172,6 +172,7 @@ enum {
     PROP_ENABLE_MEDIA,
     PROP_MEDIA_CONTENT_TYPES_REQUIRING_HARDWARE_SUPPORT,
     PROP_ENABLE_WEBRTC,
+    PROP_ENABLE_WEBSECURITY,
     N_PROPERTIES,
 };

@@ -402,6 +403,9 @@ ALLOW_DEPRECATED_DECLARATIONS_END
     case PROP_ENABLE_WEBRTC:
         webkit_settings_set_enable_webrtc(settings, g_value_get_boolean(value));
         break;
+    case PROP_ENABLE_WEBSECURITY:
+        webkit_settings_set_enable_websecurity(settings, g_value_get_boolean(value));
+        break;
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID(object, propId, paramSpec);
         break;
@@ -603,6 +607,9 @@ ALLOW_DEPRECATED_DECLARATIONS_END
     case PROP_ENABLE_WEBRTC:
         g_value_set_boolean(value, webkit_settings_get_enable_webrtc(settings));
         break;
+    case PROP_ENABLE_WEBSECURITY:
+        g_value_set_boolean(value, webkit_settings_get_enable_websecurity(settings));
+        break;
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID(object, propId, paramSpec);
         break;
@@ -1588,6 +1595,25 @@ static void webkit_settings_class_init(WebKitSettingsClass* klass)
         FALSE,
         readWriteConstructParamFlags);

+    /**
+     * WebKitSettings:enable-websecurity:
+     *
+     * Enable or disable support for Web Security on pages.
+     *
+     * This setting disables the same-origin policy, allowing every website full control over
+     * all other websites. This is for use in special environments where you wish to disable
+     * all security and allow websites to hack each other. It is impossible to use this setting
+     * securely.
+     *
+     * Since: 2.38
+     */
+    sObjProperties[PROP_ENABLE_WEBSECURITY] = g_param_spec_boolean(
+        "enable-websecurity",
+        _("Enable websecurity"),
+        _("Whether websecurity should be enabled."),
+        TRUE,
+        readWriteConstructParamFlags);
+
     g_object_class_install_properties(gObjectClass, N_PROPERTIES, sObjProperties);
 }

@@ -3958,3 +3984,42 @@ void webkit_settings_set_media_content_types_requiring_hardware_support(WebKitSe
     priv->mediaContentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupportString.utf8();
     g_object_notify_by_pspec(G_OBJECT(settings), sObjProperties[PROP_MEDIA_CONTENT_TYPES_REQUIRING_HARDWARE_SUPPORT]);
 }
+
+/**
+ * webkit_settings_get_enable_websecurity:
+ * @settings: a #WebKitSettings
+ *
+ * Get the #WebKitSettings:enable-websecurity property.
+ *
+ * Returns: %TRUE If websecurity support is enabled or %FALSE otherwise.
+ *
+ * Since: 2.38
+*/
+gboolean webkit_settings_get_enable_websecurity(WebKitSettings* settings)
+{
+    g_return_val_if_fail(WEBKIT_IS_SETTINGS(settings), FALSE);
+
+    return settings->priv->preferences->webSecurityEnabled();
+}
+
+/**
+ * webkit_settings_set_enable_websecurity:
+ * @settings: a #WebKitSettings
+ * @enabled: Value to be set
+ *
+ * Set the #WebKitSettings:enable-websecurity property.
+ *
+ * Since: 2.38
+ */
+void webkit_settings_set_enable_websecurity(WebKitSettings* settings, gboolean enabled)
+{
+    g_return_if_fail(WEBKIT_IS_SETTINGS(settings));
+
+    WebKitSettingsPrivate* priv = settings->priv;
+    bool currentValue = priv->preferences->webSecurityEnabled();
+    if (currentValue == enabled)
+        return;
+
+    priv->preferences->setWebSecurityEnabled(enabled);
+    g_object_notify_by_pspec(G_OBJECT(settings), sObjProperties[PROP_ENABLE_WEBSECURITY]);
+}
diff --git a/Source/WebKit/UIProcess/API/wpe/WebKitSettings.h b/Source/WebKit/UIProcess/API/wpe/WebKitSettings.h
index 09d8ead0..31805556 100644
--- a/Source/WebKit/UIProcess/API/wpe/WebKitSettings.h
+++ b/Source/WebKit/UIProcess/API/wpe/WebKitSettings.h
@@ -479,6 +479,12 @@ WEBKIT_API void
 webkit_settings_set_enable_webrtc                              (WebKitSettings *settings,
                                                                 gboolean enabled);

+WEBKIT_API gboolean
+webkit_settings_get_enable_websecurity                         (WebKitSettings *settings);
+
+WEBKIT_API void
+webkit_settings_set_enable_websecurity                         (WebKitSettings *settings,
+                                                                gboolean        enabled);
 G_END_DECLS

 #endif /* WebKitSettings_h */
diff --git a/Tools/TestWebKitAPI/Tests/WebKitGLib/TestWebKitSettings.cpp b/Tools/TestWebKitAPI/Tests/WebKitGLib/TestWebKitSettings.cpp
index e224df80..9e8d78a2 100644
--- a/Tools/TestWebKitAPI/Tests/WebKitGLib/TestWebKitSettings.cpp
+++ b/Tools/TestWebKitAPI/Tests/WebKitGLib/TestWebKitSettings.cpp
@@ -378,6 +378,11 @@ ALLOW_DEPRECATED_DECLARATIONS_BEGIN
     Test::addLogFatalFlag(G_LOG_LEVEL_WARNING);
 ALLOW_DEPRECATED_DECLARATIONS_END

+    // WebSecurity is enabled by default.
+    g_assert_true(webkit_settings_get_enable_websecurity(settings));
+    webkit_settings_set_enable_websecurity(settings, FALSE);
+    g_assert_false(webkit_settings_get_enable_websecurity(settings));
+
     g_object_unref(G_OBJECT(settings));
 }

--
2.34.1
EOF
}

function patch_webkit_fix_webgl_compositing
{
    patch -d $WPEWEBKIT -f -l -p1 <<"EOF"
From 27ae138797fe25edf333771c440cc87bc7e19fcc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lo=C3=AFc=20Le=20Page?= <llepage@igalia.com>
Date: Thu, 12 Jan 2023 15:42:50 +0100
Subject: [PATCH] [WPE][WebGL][Canvas][Compositing] Fix partially rendered
 WebGL canvas compositing issue

When rendering heavy 3D scenes in a WebGL canvas using the WPE EGL
renderer, the compositor may use the element render target texture
BEFORE all the WebGL commands are correctly executed by the GPU.

Then, on most complex frames, the canvas appears totally blank or
partially rendered. This patch ensures that all GL commands from
the WebGL canvas context are finished before using the render target
texture in the compositor.
---
 .../platform/graphics/egl/GLContextEGL.cpp    |  4 +++
 .../nicosia/texmap/NicosiaGCGLLayer.cpp       |  5 +++
 .../opengl/GraphicsContextGLOpenGL.cpp        | 18 ++++++++++-
 .../graphics/opengl/GraphicsContextGLOpenGL.h |  3 ++
 .../TextureMapperPlatformLayerBuffer.cpp      | 32 +++++++++++++++++++
 .../texmap/TextureMapperPlatformLayerBuffer.h |  7 ++++
 6 files changed, 68 insertions(+), 1 deletion(-)

diff --git a/Source/WebCore/platform/graphics/egl/GLContextEGL.cpp b/Source/WebCore/platform/graphics/egl/GLContextEGL.cpp
index 262b2fb9..d5efa070 100644
--- a/Source/WebCore/platform/graphics/egl/GLContextEGL.cpp
+++ b/Source/WebCore/platform/graphics/egl/GLContextEGL.cpp
@@ -517,7 +517,11 @@ bool GLContextEGL::makeContextCurrent()
 void GLContextEGL::swapBuffers()
 {
     if (m_type == Surfaceless)
+    {
+        eglWaitClient();
+        eglWaitNative(EGL_CORE_NATIVE_ENGINE);
         return;
+    }

     ASSERT(m_surface);
     eglSwapBuffers(m_display.eglDisplay(), m_surface);
diff --git a/Source/WebCore/platform/graphics/nicosia/texmap/NicosiaGCGLLayer.cpp b/Source/WebCore/platform/graphics/nicosia/texmap/NicosiaGCGLLayer.cpp
index 35843b33..57c766da 100644
--- a/Source/WebCore/platform/graphics/nicosia/texmap/NicosiaGCGLLayer.cpp
+++ b/Source/WebCore/platform/graphics/nicosia/texmap/NicosiaGCGLLayer.cpp
@@ -91,7 +91,12 @@ void GCGLLayer::swapBuffersIfNeeded()
         auto& proxy = downcast<Nicosia::ContentLayerTextureMapperImpl>(m_contentLayer->impl()).proxy();
         Locker locker { proxy.lock() };
         ASSERT(is<TextureMapperPlatformLayerProxyGL>(proxy));
+#if USE(LIBEPOXY)
+        downcast<TextureMapperPlatformLayerProxyGL>(proxy).pushNextBuffer(makeUnique<TextureMapperPlatformLayerBuffer>(m_context.m_compositorTexture, m_context.m_compositorTextureFence, textureSize, flags, m_context.m_internalColorFormat));
+        m_context.m_compositorTextureFence = nullptr;
+#else
         downcast<TextureMapperPlatformLayerProxyGL>(proxy).pushNextBuffer(makeUnique<TextureMapperPlatformLayerBuffer>(m_context.m_compositorTexture, textureSize, flags, m_context.m_internalColorFormat));
+#endif // USE(LIBEPOXY)
     }

     m_context.markLayerComposited();
diff --git a/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.cpp b/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.cpp
index 3ddaa004..be0902bc 100644
--- a/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.cpp
+++ b/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.cpp
@@ -135,6 +135,10 @@ GraphicsContextGLOpenGL::~GraphicsContextGLOpenGL()
 #if USE(COORDINATED_GRAPHICS)
     if (m_compositorTexture)
         ::glDeleteTextures(1, &m_compositorTexture);
+#if USE(LIBEPOXY)
+    if (m_compositorTextureFence)
+        ::glDeleteSync(m_compositorTextureFence);
+#endif
 #endif

     auto attributes = contextAttributes();
@@ -399,9 +403,21 @@ void GraphicsContextGLOpenGL::prepareTexture()
 #if USE(COORDINATED_GRAPHICS)
     std::swap(m_texture, m_compositorTexture);
     std::swap(m_texture, m_intermediateTexture);
+
+#if USE(LIBEPOXY)
+    if (::glFenceSync) {
+        if (m_compositorTextureFence)
+            ::glDeleteSync(m_compositorTextureFence);
+
+        m_compositorTextureFence = ::glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+    } else {
+        ::glFinish();
+    }
+#endif
+
     ::glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
     ::glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, m_texture, 0);
-    glFlush();
+    ::glFlush();

     ASSERT(m_state.boundReadFBO == m_state.boundDrawFBO);
     if (m_state.boundDrawFBO != m_fbo)
diff --git a/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.h b/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.h
index 69cfda06..8d5c8b58 100644
--- a/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.h
+++ b/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.h
@@ -550,6 +550,9 @@ protected:
 #if USE(COORDINATED_GRAPHICS)
     GCGLuint m_compositorTexture { 0 };
     GCGLuint m_intermediateTexture { 0 };
+#if USE(LIBEPOXY)
+    GLsync m_compositorTextureFence { nullptr };
+#endif // USE(LIBEPOXY)
 #endif

 #if USE(OPENGL_ES)
diff --git a/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp b/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp
index d401f6db..a7afea49 100644
--- a/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp
+++ b/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp
@@ -41,10 +41,22 @@ TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(RefPtr<Bitmap
 {
 }

+#if USE(LIBEPOXY)
+TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(GLuint textureID, GLsync textureFence, const IntSize& size, TextureMapperGL::Flags flags, GLint internalFormat)
+    : m_variant(RGBTexture { textureID })
+    , m_textureFence(textureFence)
+    , m_size(size)
+    , m_internalFormat(internalFormat)
+    , m_extraFlags(flags)
+    , m_hasManagedTexture(false)
+{
+}
+#else
 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize& size, TextureMapperGL::Flags flags, GLint internalFormat)
     : TextureMapperPlatformLayerBuffer({ RGBTexture { textureID } }, size, flags, internalFormat)
 {
 }
+#endif // USE(LIBEPOXY)

 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(TextureVariant&& variant, const IntSize& size, TextureMapperGL::Flags flags, GLint internalFormat)
     : m_variant(WTFMove(variant))
@@ -57,6 +69,10 @@ TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(TextureVarian

 TextureMapperPlatformLayerBuffer::~TextureMapperPlatformLayerBuffer()
 {
+#if USE(LIBEPOXY)
+    if (m_textureFence)
+        glDeleteSync(m_textureFence);
+#endif // USE(LIBEPOXY)
 }

 bool TextureMapperPlatformLayerBuffer::canReuseWithoutReset(const IntSize& size, GLint internalFormat)
@@ -66,6 +82,14 @@ bool TextureMapperPlatformLayerBuffer::canReuseWithoutReset(const IntSize& size,

 std::unique_ptr<TextureMapperPlatformLayerBuffer> TextureMapperPlatformLayerBuffer::clone()
 {
+#if USE(LIBEPOXY)
+    if (m_textureFence) {
+        glWaitSync(m_textureFence, 0, GL_TIMEOUT_IGNORED);
+        glDeleteSync(m_textureFence);
+        m_textureFence = nullptr;
+    }
+#endif // USE(LIBEPOXY)
+
     if (m_hasManagedTexture) {
         notImplemented();
         return nullptr;
@@ -99,6 +123,14 @@ void TextureMapperPlatformLayerBuffer::paintToTextureMapper(TextureMapper& textu
 {
     TextureMapperGL& texmapGL = static_cast<TextureMapperGL&>(textureMapper);

+#if USE(LIBEPOXY)
+    if (m_textureFence) {
+        glWaitSync(m_textureFence, 0, GL_TIMEOUT_IGNORED);
+        glDeleteSync(m_textureFence);
+        m_textureFence = nullptr;
+    }
+#endif // USE(LIBEPOXY)
+
     if (m_hasManagedTexture) {
         ASSERT(m_texture);
         BitmapTextureGL* textureGL = static_cast<BitmapTextureGL*>(m_texture.get());
diff --git a/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h b/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h
index ed209d09..e565c59d 100644
--- a/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h
+++ b/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h
@@ -41,7 +41,11 @@ class TextureMapperPlatformLayerBuffer : public TextureMapperPlatformLayer {
 public:
     TextureMapperPlatformLayerBuffer(RefPtr<BitmapTexture>&&, TextureMapperGL::Flags = 0);

+#if USE(LIBEPOXY)
+    TextureMapperPlatformLayerBuffer(GLuint textureID, GLsync textureFence, const IntSize&, TextureMapperGL::Flags, GLint internalFormat);
+#else
     TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize&, TextureMapperGL::Flags, GLint internalFormat);
+#endif // USE(LIBEPOXY)

     struct RGBTexture {
         GLuint id;
@@ -102,6 +106,9 @@ public:

 protected:
     TextureVariant m_variant;
+#if USE(LIBEPOXY)
+    GLsync m_textureFence = { nullptr };
+#endif // USE(LIBEPOXY)

 private:
     RefPtr<BitmapTexture> m_texture;
--
2.34.1
EOF
}

function prepare_sources
{
    mkdir -p $BASE_DIR/sources
    cd $BASE_DIR/sources

    local SRC_PACKAGE
    for SRC_PACKAGE in $LIBWPE $WPEWEBKIT; do
        if [ ! -d $SRC_PACKAGE ]; then
            if [ ! -f $SRC_PACKAGE.tar.xz ]; then
                wget https://wpewebkit.org/releases/$SRC_PACKAGE.tar.xz
            fi
            tar -xf $SRC_PACKAGE.tar.xz

            if [ "$SRC_PACKAGE" = "$WPEWEBKIT" ]; then
                patch_webkit_wait_for_wpewebprocess
                patch_webkit_enable_websecurity
                patch_webkit_fix_webgl_compositing
            fi
        fi
    done
}

function build_libwpe
{
    cd $BASE_DIR/sources/$LIBWPE
    if [ ! -f build/build.ninja ]; then
        rm -rf build
        meson setup --buildtype=$MESON_BUILD_TYPE --prefix=$INSTALL_PREFIX build
    fi

    ninja -C build install
    patchelf --set-rpath '$ORIGIN' --force-rpath $INSTALL_PREFIX/lib/x86_64-linux-gnu/libwpe-1.0.so
}

function build_wpewebkit
{
    cd $BASE_DIR/sources/$WPEWEBKIT
    if [ ! -f build/build.ninja ]; then
        rm -rf build
        cmake -S. -Bbuild -GNinja -DCMAKE_EXPORT_COMPILE_COMMANDS=TRUE \
            -DCMAKE_BUILD_TYPE=$CMAKE_BUILD_TYPE -DCMAKE_INSTALL_PREFIX=$INSTALL_PREFIX \
            -DPORT=WPE -DENABLE_ACCESSIBILITY=OFF -DENABLE_BUBBLEWRAP_SANDBOX=OFF -DENABLE_DOCUMENTATION=OFF \
            -DENABLE_GAMEPAD=OFF -DENABLE_INTROSPECTION=OFF -DENABLE_JOURNALD_LOG=OFF \
            -DENABLE_OFFSCREEN_CANVAS=ON -DENABLE_OFFSCREEN_CANVAS_IN_WORKERS=ON \
            -DENABLE_PDFJS=OFF -DENABLE_WEBDRIVER=OFF -DUSE_SOUP2=ON -DUSE_AVIF=OFF \
            -DENABLE_WPE_QT_API=OFF -DENABLE_COG=OFF -DENABLE_MINIBROWSER=OFF
    fi

    ninja -C build install
    patchelf --set-rpath '$ORIGIN/../..' --force-rpath $INSTALL_PREFIX/lib/wpe-webkit-1.0/injected-bundle/libWPEInjectedBundle.so
    patchelf --set-rpath '$ORIGIN/../../lib' --force-rpath $INSTALL_PREFIX/libexec/wpe-webkit-1.0/WPENetworkProcess
    patchelf --set-rpath '$ORIGIN/../../lib' --force-rpath $INSTALL_PREFIX/libexec/wpe-webkit-1.0/WPEWebProcess
    patchelf --set-rpath '$ORIGIN/x86_64-linux-gnu' --force-rpath $INSTALL_PREFIX/lib/libWPEWebKit-1.0.so

    if [ "$CMAKE_BUILD_TYPE" != "Release" ]; then
        gdb-add-index $INSTALL_PREFIX/lib/libWPEWebKit-1.0.so
        cp -fL $INSTALL_PREFIX/lib/libWPEWebKit-1.0.so $INSTALL_PREFIX/lib/libWPEWebKit-1.0.so.debug
        strip --strip-debug $INSTALL_PREFIX/lib/libWPEWebKit-1.0.so
    fi
}

function build
{
    prepare_sources
    build_libwpe
    build_wpewebkit
}

if [ ! -d $BASE_DIR ]; then
    mkdir -p $BASE_DIR
    install_build_deps
    build
elif [ "$BUILD_DEPS" = "true" -o ! -d $INSTALL_PREFIX ]; then
    build
fi

export WEBKIT_INSPECTOR_SERVER=127.0.0.1:8787

export __NV_PRIME_RENDER_OFFLOAD=1
export __GLX_VENDOR_LIBRARY_NAME=nvidia
export __GL_SYNC_TO_VBLANK=1
export LD_LIBRARY_PATH=$(readlink -mn $BASE_DIR/../../build/backend)

cd $BASE_DIR/../..
$SHELL

exit 0
